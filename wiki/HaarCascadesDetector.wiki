#summary Viola-Jones object detection using Adobe Flash.
#labels Featured

= Haar Cascades Detector =

[http://farm5.static.flickr.com/4016/4474350420_58c3386fc1_o.png]

Simplified for the best performance implementation of [http://en.wikipedia.org/wiki/Viola-Jones_object_detection_framework Viola-Jones object detection] using Adobe Flash.

=== Features ===

  * Stump and Tree based cascades XML files
  * Built in Region of interest support
  * Optional start detection size, scale up speed and region analyzation step factor
  * Optional Edges Map to speed up process by skipping low-edged areas

=== Usage info ===

{{{
// init detector instance. second argument is to set if cascade file is Tree based or not
var detector:HaarCascadesDetector = new HaarCascadesDetector(cascadeXML, false);

// setting image to use for detection
detector.image = bitmapDataObject;

// now we call detect method to find all available objects
// please note that detector uses only BLUE channel of the image
// so u have to GRAYSCALE it first. I haven't included this operation inside
// to allow users make any pre-processing operations with the image

// bounds Rectangle - where to search our object

// base Scale factor of initial search window size 
// ex. if cascade size is 20x20 and u specify base scale 1.2 
// detector will start analyzation from window size: 20*1.2 x 20*1.2

// scale Increment factor of window scale up during analyzation cycles

// step Increment factor of window analyzation ex. when we have window size 20x20
// and step increment 0.1 it will divide each size of window into steps to process 
// 20*0.1 = 10 steps in width and 20*0.1 = 10 steps in height

// edgeBitmap - you can provide BitmapData object with detected edges to speed up
// detection process. (I recommend to use CannyEdgeDetector)

// otherDetector - instance of other HaarCascadesDetector
// useful when you using several detectors with one image.
// it will use calculated image data from other detector

var rects:Vector.<Rectangle> = detector.detect(boundsRectangle, baseScale, scaleIncrement, stepIncrement, edgeBitmap, otherDetector);

// if we found smth it will be in rects Vector object
// however there may be too much rectangles that represent the same object
// you can filter them yourself or use built it merge method

rects = detector.merge(rects);

// now you only have to draw result rectangles or to use them for other analyzation

}}}

=== Usage example ===

{{{
const XML_FACE_URL:String = 'haarcascade_frontalface_default.xml';
const XML_MOUTH_URL:String = 'haarcascade_mcs_mouth.xml';
const XML_L_EYE_URL:String = 'haarcascade_mcs_lefteye.xml';
const XML_R_EYE_URL:String = 'haarcascade_mcs_righteye.xml';

const ZIP_XML_URL:String = 'cascades.zip'; // zip file including all XML files mentioned above

var detectorFace:HaarCascadesDetector;
var detectorMouth:HaarCascadesDetector;
var detectorLEye:HaarCascadesDetector;
var detectorREye:HaarCascadesDetector;

var canny:CannyEdgeDetector; // ru.inspirit.image.CannyEdgeDetector

var faceRectContainer :Sprite;
var camera:CameraBitmap; // com.quasimondo.bitmapdata.CameraBitmap
var detectionMap:BitmapData;
var edgesMap:BitmapData;
var drawMatrix:Matrix;
var scaleFactor:Number = 3;
var w:int = 640;
var h:int = 480;

var cm:ColorMatrix = new ColorMatrix(); // com.quasimondo.geom.ColorMatrix

var baseScale:Number = 1.5;
var scaleIncrement:Number = 1.25;
var stepIncrement:Number = 0.05;
var edgeDensity:Number = 0.09;

function init():void 
{	
	camera = new CameraBitmap( w, h, 20 );
	addChild( new Bitmap( camera.bitmapData ) );
	
	detectionMap = new BitmapData( w / scaleFactor, h / scaleFactor, false, 0 );
	edgesMap = detectionMap.clone();
	drawMatrix = new Matrix( 1 / scaleFactor, 0, 0, 1 / scaleFactor );
	
	detectionMap.lock();
	edgesMap.lock();
	
	faceRectContainer = new Sprite();
	
	addChild( faceRectContainer );
	
	var myLoader:URLLoader = new URLLoader();
	myLoader.dataFormat = URLLoaderDataFormat.BINARY;
	myLoader.addEventListener(Event.COMPLETE, onUnZipComplete);
	myLoader.load(new URLRequest(ZIP_XML_URL)); // load zip archive file
}

function onRender(e:Event):void
{
	detectionMap.draw(camera.bitmapData, drawMatrix, null, "normal", null, true);
	
	cm.reset();
	cm.desaturate();
	cm.applyFilter(detectionMap);
	
	canny.detectEdges(edgesMap);
	
	// first detect all available faces
	var faceRects:Vector.<Rectangle> = detectorFace.detect(null, baseScale, scaleIncrement, stepIncrement, edgesMap);
	
	if(faceRects.length > 1) 
	{
		faceRects = detectorFace.merge(faceRects);
	}
	
	// draw face rectangles
	drawRects(faceRects, scaleFactor);
	
	var n:int = faceRects.length;
	
	// if we have face(s) lets try to estimate eyes and mouth positions
	if(n)
	{
		for(var i:int = 0; i < n; ++i)
		{
			detectEyesAndMouth(faceRects[i]);
		}
	}
}

function detectEyesAndMouth(r:Rectangle):void
{
	var eyeRects:Vector.<Rectangle>;
	
	var eyes_r:Rectangle = r.clone();
	var mouth_r:Rectangle = eyes_r.clone();
	
	// LEFT EYE
	// try to predict eye rectangle area
	eyes_r.height *= 0.375;
	eyes_r.width *= 0.5;
	eyes_r.y += eyes_r.height * 0.5;
	
	eyeRects = detectorLEye.detect(eyes_r, 1, 1.1, 0.05, null, detectorFace);
	
	if(eyeRects.length > 1) eyeRects = detectorLEye.merge(eyeRects);
	drawCircles(eyeRects, scaleFactor, false);
	
	// RIGHT EYE
	
	eyes_r.x += eyes_r.width;
	
	eyeRects = detectorREye.detect(eyes_r, 1, 1.2, 0.05, null, detectorFace);
	
	if(eyeRects.length > 1) eyeRects = detectorLEye.merge(eyeRects);
	drawCircles(eyeRects, scaleFactor, false);
	
	// MOUTH
	// try to predict mouth rectangle area
	mouth_r.y = mouth_r.bottom - mouth_r.height * 0.4;
	mouth_r.x += mouth_r.width * 0.125;
	mouth_r.width *= 0.75;
	mouth_r.height *= 0.375;
	
	eyeRects = detectorMouth.detect(mouth_r, 1, 1.1, 0.05, null, detectorFace);
	
	if(eyeRects.length > 1) eyeRects = detectorMouth.merge(eyeRects);
	drawRects(eyeRects, scaleFactor, false);
}

function drawCircles(faceRects:Vector.<Rectangle>, scale:Number = 1, clear:Boolean = true):void
{
	var g:Graphics = faceRectContainer.graphics;
	if(clear) g.clear();
	g.lineStyle(2, 0x00ff00);
	for(var i:int = 0; i < faceRects.length; ++i)
	{
		var size:int = (faceRects[i].width * scale);
		g.drawCircle(faceRects[i].x * scale + (size>>1), faceRects[i].y * scale + (size>>1), size>>1);
	}
}
function drawRects(faceRects:Vector.<Rectangle>, scale:Number = 1, clear:Boolean = true):void
{	
	var g:Graphics = faceRectContainer.graphics;
	if(clear) g.clear();
	g.lineStyle(2, 0x00ff00);
	for(var i:int = 0; i < faceRects.length; ++i)
	{
		g.drawRect(faceRects[i].x * scale, faceRects[i].y * scale, faceRects[i].width * scale, faceRects[i].height * scale);
	}
}

function onUnZipComplete(e:Event):void
{
	// init ZipFile
	var zipFile:ZipFile = new ZipFile(URLLoader(e.currentTarget).data as ByteArray); // nochump.util.zip.ZipFile
	
	// extract cascades XML
	// and init each dector instance
	
	var entry:ZipEntry = zipFile.getEntry(XML_FACE_URL);
	var data:ByteArray = zipFile.getInput(entry);
	var myXML:XML = XML(data.toString());
	detectorFace = new HaarCascadesDetector(myXML, false);
	detectorFace.image = detectionMap;
	
	entry = zipFile.getEntry(XML_MOUTH_URL);
	data = zipFile.getInput(entry);
	myXML = XML(data.toString());
	detectorMouth = new HaarCascadesDetector(myXML, false);
	detectorMouth.image = detectionMap;
	
	entry = zipFile.getEntry(XML_L_EYE_URL);
	data = zipFile.getInput(entry);
	myXML = XML(data.toString());
	detectorLEye = new HaarCascadesDetector(myXML, false);
	detectorLEye.image = detectionMap;
	
	entry = zipFile.getEntry(XML_R_EYE_URL);
	data = zipFile.getInput(entry);
	myXML = XML(data.toString());
	detectorREye = new HaarCascadesDetector(myXML, false);
	detectorREye.image = detectionMap;
	
	canny = new CannyEdgeDetector(detectionMap);
	detectorFace.edgesDensity = 255 * edgeDensity;
	
	camera.addEventListener( Event.RENDER, onRender ); // start detection
}
}}}

=== Download ===

[http://in-spirit.googlecode.com/files/HaarCascadesDetector.swc.zip HaarCascadesDetector.swc download]